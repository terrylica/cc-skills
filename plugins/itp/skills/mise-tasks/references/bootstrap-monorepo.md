# Meta-Prompt: Autonomous Polyglot Monorepo Bootstrap

> **Role**: You are a Principal Software Architect specializing in AI-native monorepo design.
> **Mission**: Construct a production-grade polyglot monorepo from scratch, optimized for agentic workflows with Claude Code CLI.
> **Constraint**: The human will not touch any code. You execute everything autonomously, verifying at each phase.

---

## Tooling Stack: Pants + mise

This bootstrap uses **Pants + mise** for 10-50 Python-heavy polyglot packages:

| Tool      | Responsibility                                                         |
| --------- | ---------------------------------------------------------------------- |
| **mise**  | Runtime versions (Python, Node, Rust) + environment variables          |
| **Pants** | Build orchestration + native affected detection + dependency inference |

→ See [polyglot-affected.md](./polyglot-affected.md) for tool comparison and scaling guidance

---

## Phase 0: Pre-Flight Verification

Before creating any files, verify the environment:

```bash
# Check required tools exist
command -v mise && mise --version
command -v git && git --version
command -v cargo && cargo --version
command -v uv && uv --version
command -v bun && bun --version
command -v pants && pants --version
```

If any tool is missing, install via mise (Pants via pip):

```bash
mise use -g rust@latest python@3.12 node@lts bun@latest uv@latest
pip install pantsbuild.pants
```

Create project root and initialize git:

```bash
mkdir -p ~/projects/hft-monorepo && cd ~/projects/hft-monorepo
git init
```

---

## Phase 1: Foundational Structure

Create the canonical directory structure for a polyglot HFT monorepo:

```
hft-monorepo/
├── CLAUDE.md                    # Hub: Link Farm root (this file)
├── mise.toml                    # Orchestrator: tools + env vars
├── pants.toml                   # Build system: orchestration + affected
├── BUILD                        # Root BUILD file
├── .mise/                       # Mise local config
├── .mcp.json                    # MCP server configuration
├── .claude/                     # Claude Code configuration
│   └── skills/                  # Project-local skill modules
│       ├── python/
│       │   └── SKILL.md
│       ├── rust/
│       │   └── SKILL.md
│       └── bun/
│           └── SKILL.md
├── docs/                        # Deep documentation (spoke)
│   ├── ARCHITECTURE.md
│   ├── LOGGING.md
│   ├── TESTING.md
│   └── WORKFLOWS.md
├── packages/                    # Polyglot packages
│   ├── core-python/             # Python: shared utilities
│   │   ├── CLAUDE.md            # Child hub
│   │   ├── BUILD                # Pants target: python_sources()
│   │   ├── pyproject.toml
│   │   └── src/
│   ├── core-rust/               # Rust: performance-critical
│   │   ├── CLAUDE.md            # Child hub
│   │   ├── BUILD                # Pants target: cargo_package()
│   │   ├── Cargo.toml
│   │   └── src/
│   ├── core-bun/                # Bun: async I/O, APIs
│   │   ├── CLAUDE.md            # Child hub
│   │   ├── BUILD                # Pants target: javascript_sources()
│   │   ├── package.json
│   │   └── src/
│   └── shared-types/            # Cross-language type definitions
│       ├── CLAUDE.md
│       ├── BUILD
│       └── schemas/
├── services/                    # Deployable services
│   ├── data-ingestion/
│   │   ├── CLAUDE.md
│   │   └── BUILD
│   ├── strategy-engine/
│   │   ├── CLAUDE.md
│   │   └── BUILD
│   └── execution-gateway/
│       ├── CLAUDE.md
│       └── BUILD
├── rules/                       # ast-grep rule directories
│   ├── general/                 # Cross-language patterns (secrets, etc.)
│   ├── python/                  # Python-specific rules
│   ├── rust/                    # Rust-specific rules
│   └── typescript/              # TypeScript-specific rules
├── scripts/                     # Automation scripts
│   └── generate-types.sh        # Code generation from schemas
└── logs/                        # Local log output (gitignored)
```

Execute creation:

```bash
mkdir -p .claude/skills/{python,rust,bun} docs packages/{core-python/src,core-rust/src,core-bun/src,shared-types/schemas} services/{data-ingestion,strategy-engine,execution-gateway} rules/{general,python,rust,typescript} scripts logs
touch .gitignore BUILD sgconfig.yml
```

---

## Phase 2: Root CLAUDE.md — The Hub

Create the root `CLAUDE.md` as the Link Farm hub with Progressive Disclosure:

```markdown
# HFT Polyglot Monorepo

> **Navigation**: This file is the single entry point. Each section links to deeper documentation. Child directories contain their own `CLAUDE.md` files that Claude loads on-demand.

## Quick Reference

| Action         | Command                                       |
| -------------- | --------------------------------------------- |
| Build affected | `pants --changed-since=origin/main package`   |
| Test affected  | `pants --changed-since=origin/main test`      |
| Lint all       | `pants lint ::`                               |
| Generate BUILD | `pants tailor`                                |
| Search code    | Use `ck` MCP tool: `semantic_search("query")` |

## Architecture Overview

**Stack**: Python (uv) · Rust (cargo) · Bun · Pants (build) · Mise (runtimes)
**Pattern**: Polyglot monorepo with independent semantic versioning
**AI Interface**: Claude Code CLI via MCP servers

→ Deep dive: [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md)

## Package Map

| Package        | Language | Purpose                       | Entry                                                              |
| -------------- | -------- | ----------------------------- | ------------------------------------------------------------------ |
| `core-python`  | Python   | Shared utilities, data models | [packages/core-python/CLAUDE.md](packages/core-python/CLAUDE.md)   |
| `core-rust`    | Rust     | Performance-critical compute  | [packages/core-rust/CLAUDE.md](packages/core-rust/CLAUDE.md)       |
| `core-bun`     | Bun/TS   | Async I/O, HTTP APIs          | [packages/core-bun/CLAUDE.md](packages/core-bun/CLAUDE.md)         |
| `shared-types` | Multi    | Cross-language schemas        | [packages/shared-types/CLAUDE.md](packages/shared-types/CLAUDE.md) |

## Workflow Protocol

When modifying code in this repo:

1. **Explore** — Read the relevant `CLAUDE.md` in the target directory
2. **Search** — Use `semantic_search` MCP tool to find related code
3. **Affected** — Run `pants --changed-since=origin/main list` to identify impacted targets
4. **Plan** — State approach before editing (ultrathink if complex)
5. **Implement** — Make changes, running `pants lint` after each file
6. **Test** — Run `pants --changed-since=origin/main test` before committing
7. **Verify** — Confirm logs emit correctly to `logs/`

→ Deep dive: [docs/WORKFLOWS.md](docs/WORKFLOWS.md)
```

---

## Phase 3: Configuration Files

### pants.toml

```toml
# SSoT-OK: placeholder versions for documentation
[GLOBAL]
pants_version = "<version>"
backend_packages = [
    "pants.backend.python",
    "pants.backend.python.lint.ruff",
    "pants.backend.experimental.rust",
    "pants.backend.experimental.javascript",
]

[python]
interpreter_constraints = [">=3.12"]

[source]
root_patterns = ["packages/*", "services/*"]

[python-bootstrap]
search_path = ["<PATH>"]

[anonymous-telemetry]
enabled = false
```

### mise.toml

> **CRITICAL**: Use `read_file()` for tokens, NOT `exec()`. The `exec()` pattern spawns subprocesses on every shell command, causing process storms. See [ADR: mise-env-token-loading-patterns](https://github.com/terrylica/cc-skills/blob/main/docs/adr/2026-01-15-mise-env-token-loading-patterns.md).

```toml
[env]
# CORRECT: read_file() - no subprocess spawning
GH_TOKEN = "{{ read_file(path=env.HOME ~ '/.claude/.secrets/gh-token-<account>') | trim }}"
GITHUB_TOKEN = "{{ read_file(path=env.HOME ~ '/.claude/.secrets/gh-token-<account>') | trim }}"

# WRONG: exec() causes process storms - NEVER USE THIS
# GH_TOKEN = "{{ exec(command='cat ~/.claude/.secrets/gh-token') }}"

LOG_DIR = "{{config_root}}/logs"
ENV = "dev"
PANTS_CONCURRENT = "true"

# SSoT-OK: placeholder versions for documentation
[tools]
python = "<version>"
rust = "<version>"
node = "<version>"
bun = "<version>"
uv = "<version>"
"cargo:ast-grep" = "latest"  # Structural code search

# Convenience wrappers for Pants commands
[tasks."test:affected"]
description = "Test affected packages via Pants"
run = "pants --changed-since=origin/main test"

[tasks."lint:affected"]
description = "Lint affected packages via Pants"
run = "pants --changed-since=origin/main lint"

[tasks.lint]
description = "Lint all packages"
run = "pants lint ::"

[tasks.test]
description = "Test all packages"
run = "pants test ::"

[tasks.affected]
description = "List packages affected by git changes"
run = "pants --changed-since=origin/main list"

[tasks."pants:tailor"]
description = "Generate BUILD files"
run = "pants tailor"
```

### Root pyproject.toml (Workspace)

Dev dependencies are **hoisted to workspace root** for single-command installation. This eliminates "unnecessary package" warnings from `uv sync` and provides a unified dev environment.

```toml
# SSoT-OK: example workspace root configuration
[project]
name = "hft-monorepo"
version = "<version>"
requires-python = ">=3.12"
# Only workspace orchestration deps at root
dependencies = []

[tool.uv.workspace]
members = ["packages/*"]

# PEP 735 dependency groups - hoisted from all workspace members
# All dev tools centralized here for `uv sync --group dev`
[dependency-groups]
dev = [
    # Testing
    "pytest>=9.0.0",
    "pytest-asyncio>=1.3.0",
    "pytest-cov>=7.0.0",
    "coverage>=7.0.0",
    # Linting & formatting
    "ruff>=0.1.0",
    "mypy>=1.0.0",
    # Jupyter/notebooks (if needed)
    "ipykernel>=7.1.0",
    "jupyterlab>=4.5.0",
]
```

### Sub-Package pyproject.toml (core-python)

Sub-packages define **only runtime dependencies**. No `[dependency-groups]` - dev deps are at workspace root.

```toml
# SSoT-OK: example sub-package configuration
[project]
name = "core-python"
version = "<version>"
requires-python = ">=3.12"
dependencies = [
    "loguru",
    "platformdirs",
    "pydantic",
]

# NOTE: Dev dependencies hoisted to workspace root pyproject.toml
# Use `uv sync --group dev` from workspace root
```

> **Why hoist dev dependencies?** See [uv Managing Dependencies](https://docs.astral.sh/uv/concepts/projects/dependencies/) - PEP 735 `[dependency-groups]` in sub-packages are not automatically included by `uv sync` from root. Hoisting ensures `uv sync --group dev` installs all dev tools in one command.

### BUILD Files (Auto-generated by `pants tailor`)

```python
# packages/core-python/BUILD
python_sources()
python_tests()

# packages/core-rust/BUILD
cargo_package()

# packages/core-bun/BUILD
javascript_sources()
javascript_tests()
```

### .mcp.json

```json
{
  "mcpServers": {
    "mise": {
      "command": "mise",
      "args": ["mcp"],
      "env": {
        "MISE_EXPERIMENTAL": "1"
      }
    },
    "code-search": {
      "command": "ck",
      "args": ["--serve"],
      "cwd": "."
    },
    "shell": {
      "command": "uvx",
      "args": ["mcp-shell-server"],
      "env": {
        "ALLOW_COMMANDS": "mise,git,jq,pants,cargo,uv,bun,cat,ls,grep,head,tail,find"
      }
    }
  }
}
```

### .gitignore

```gitignore
# Logs
logs/
*.jsonl

# Dependencies
node_modules/
target/
.venv/
__pycache__/
*.pyc

# Build outputs
dist/
build/
*.egg-info/

# Pants
.pants.d/
.pids/

# IDE
.idea/
.vscode/
*.swp

# OS
.DS_Store
Thumbs.db

# Mise
.mise.local.toml

# Secrets (never commit)
.env.local
*.key
*.pem
```

### sgconfig.yml (ast-grep Configuration)

```yaml
# ast-grep rule configuration
ruleDirs:
  - rules/general
  - rules/python
  - rules/rust
  - rules/typescript

testConfigs:
  - testDir: tests/rules

utilDirs:
  - utils

languageGlobs:
  typescript: ["*.ts", "*.tsx"]
  javascript: ["*.js", "*.jsx", "*.mjs"]
  python: ["*.py", "*.pyi"]
```

### Example ast-grep Rules

**rules/general/no-hardcoded-secrets.yml** — Detect hardcoded API keys:

```yaml
id: no-hardcoded-api-key
language: python
message: Possible hardcoded API key or secret detected
severity: error
rule:
  any:
    - pattern: api_key = "$$$"
    - pattern: API_KEY = "$$$"
    - pattern: secret = "$$$"
note: |
  Never hardcode secrets. Use environment variables or Doppler.
```

**rules/python/no-print-statements.yml** — Enforce logging over print:

```yaml
id: no-print-statements
language: python
message: Use logging instead of print statements
severity: hint
rule:
  pattern: print($$$)
note: |
  Use loguru for structured logging:
  from loguru import logger
  logger.info("message")
```

**rules/typescript/no-console-log.yml** — Enforce proper logging:

```yaml
id: no-console-log
language: typescript
message: Use a proper logger instead of console.log
severity: hint
rule:
  pattern: console.log($$$)
note: |
  Use pino for structured logging:
  import pino from 'pino';
  const logger = pino();
  logger.info({ data }, "message");
```

Run rules with: `sg scan` or use ast-grep MCP for interactive searches.

---

## Phase 4: Verification Checklist

After creating all files, verify the setup:

```bash
# 1. Directory structure
find . -name "CLAUDE.md" -o -name "BUILD" | head -20

# 2. Mise configuration
mise doctor
mise tasks

# 3. Pants configuration
pants --version
pants tailor          # Generate BUILD files if needed
pants list ::         # List all targets

# 4. Affected detection (Pants native)
pants --changed-since=origin/main list

# 5. MCP configuration
cat .mcp.json | jq .

# 6. Log directory
mkdir -p logs
ls -la logs/

# 7. Git status
git status
git add -A
git commit -m "chore: initial monorepo scaffold with Pants + mise"
```

---

## Phase 5: Post-Bootstrap Tasks

Once the scaffold is complete, initialize each package:

### Python Package

```bash
cd packages/core-python
uv init
uv add loguru platformdirs pydantic
# NOTE: Dev deps are hoisted to workspace root - don't add here
# Use `uv sync --group dev` from workspace root instead
pants tailor  # Generate BUILD file
```

### Rust Package

```bash
cd packages/core-rust
cargo init --lib
# Add dependencies to Cargo.toml per skill guide
pants tailor  # Generate BUILD file
```

### Bun Package

```bash
cd packages/core-bun
bun init -y
bun add pino zod
bun add -d @biomejs/biome @types/bun
pants tailor  # Generate BUILD file
```

---

## Phase 6: Cross-Language Type Definitions

For polyglot monorepos, define types once in JSON Schema (Draft 2020-12) and generate for each language.

### JSON Schema Examples

**packages/shared-types/schemas/fitness-metrics.json**:

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "fitness-metrics.json",
  "title": "FitnessMetrics",
  "type": "object",
  "required": ["sharpeRatio", "maxDrawdown", "totalReturn"],
  "properties": {
    "sharpeRatio": { "type": "number" },
    "maxDrawdown": { "type": "number", "minimum": 0, "maximum": 1 },
    "totalReturn": { "type": "number" },
    "tradingDays": { "type": "integer", "minimum": 1 }
  }
}
```

### Code Generation Script

**scripts/generate-types.sh**:

```bash
#!/usr/bin/env bash
set -euo pipefail

SCHEMAS_DIR="packages/shared-types/schemas"

generate_python() {
    # Requires: uv pip install datamodel-code-generator
    datamodel-codegen \
        --input "$SCHEMAS_DIR" \
        --output "packages/core-python/src/generated/models.py" \
        --output-model-type pydantic_v2.BaseModel
}

generate_typescript() {
    # Requires: bun add -D json-schema-to-zod
    for schema in "$SCHEMAS_DIR"/*.json; do
        local name
        name=$(basename "$schema" .json | tr '-' '_')
        bunx json-schema-to-zod -s "$schema" -o "packages/core-bun/src/generated/${name}.ts"
    done
}

generate_rust() {
    # Requires: cargo install typify-cli
    for schema in "$SCHEMAS_DIR"/*.json; do
        local name
        name=$(basename "$schema" .json | tr '-' '_')
        typify "$schema" > "packages/core-rust/src/generated/${name}.rs"
    done
}

case "${1:-all}" in
    python) generate_python ;;
    typescript) generate_typescript ;;
    rust) generate_rust ;;
    all) generate_python; generate_typescript; generate_rust ;;
esac
```

Add mise task:

```toml
[tasks.generate-types]
description = "Generate types from JSON Schema"
run = "bash scripts/generate-types.sh all"
```

---

## Phase 7: GitHub Repository Setup

For public repositories, proper decoration improves discoverability and professionalism.

### Repository Creation and Decoration

```bash
# Create repository (if needed)
gh repo create <owner>/<repo-name> --public --source=. --push

# Add description and topics
gh repo edit <owner>/<repo-name> \
  --description "Polyglot monorepo for <domain> using Python, Rust, TypeScript" \
  --add-topic python \
  --add-topic rust \
  --add-topic typescript \
  --add-topic monorepo \
  --add-topic polyglot

# Example topics for trading/finance projects
gh repo edit <owner>/<repo-name> \
  --add-topic trading \
  --add-topic quantitative-finance \
  --add-topic backtesting \
  --add-topic numba \
  --add-topic finance
```

### Standard Labels

Create consistent labels for issue and PR management:

```bash
# Package labels (scoped by package name)
gh label create "pkg:core-python" --color "3572A5" --description "Python core package"
gh label create "pkg:core-rust" --color "DEA584" --description "Rust core package"
gh label create "pkg:core-bun" --color "F7DF1E" --description "TypeScript/Bun package"
gh label create "pkg:shared-types" --color "6E5494" --description "Cross-language schemas"

# Type labels
gh label create "type:bug" --color "D73A4A" --description "Something isn't working"
gh label create "type:feature" --color "0E8A16" --description "New feature or request"
gh label create "type:docs" --color "0075CA" --description "Documentation improvements"
gh label create "type:refactor" --color "FBCA04" --description "Code refactoring"
gh label create "type:perf" --color "7057FF" --description "Performance improvements"
gh label create "type:ci" --color "BFD4F2" --description "CI/CD pipeline changes"
```

### README Badge Patterns

Static badges using shields.io for consistent styling:

```markdown
# Project Title

[![Python](https://img.shields.io/badge/Python-3.12+-3776AB?logo=python&logoColor=white)](packages/core-python)
[![Rust](https://img.shields.io/badge/Rust-stable-DEA584?logo=rust&logoColor=white)](packages/core-rust)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.0+-3178C6?logo=typescript&logoColor=white)](packages/core-bun)
[![Tests](https://img.shields.io/badge/tests-86%20passing-brightgreen)](.)
[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
```

**Badge format**: `![Alt](https://img.shields.io/badge/<LABEL>-<MESSAGE>-<COLOR>?logo=<LOGO>&logoColor=white)`

Common colors:

| Language/Tool | Color Code  | Logo       |
| ------------- | ----------- | ---------- |
| Python        | 3776AB      | python     |
| Rust          | DEA584      | rust       |
| TypeScript    | 3178C6      | typescript |
| Node.js       | 339933      | node.js    |
| Bun           | FBF0DF      | bun        |
| MIT License   | blue        | -          |
| Tests passing | brightgreen | -          |

### LICENSE File Template (MIT)

Create `LICENSE` in root:

```text
MIT License

Copyright (c) <YEAR> <OWNER>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

### git-town Configuration

Configure git-town for streamlined branch workflows:

```bash
# Initialize git-town (one-time)
git-town config setup

# Or configure directly
git config git-town.main-branch main
git config git-town.perennial-branches ""
git config git-town.push-new-branches true
git config git-town.sync-feature-strategy rebase

# Verify configuration
git-town config
```

**Key settings**:

| Setting                 | Value    | Purpose                         |
| ----------------------- | -------- | ------------------------------- |
| `main-branch`           | `main`   | Primary integration branch      |
| `push-new-branches`     | `true`   | Auto-push new feature branches  |
| `sync-feature-strategy` | `rebase` | Keep linear history on features |

### Professional README Structure

```markdown
# Project Name

[![badges...](...)...]

Short description of the project (1-2 sentences).

## Overview

Brief explanation of what the project does and its key value proposition.

## Quick Start

\`\`\`bash

# Prerequisites

brew install mise

# Setup

git clone https://github.com/<owner>/<repo>.git
cd <repo>
mise install

# Run

mise run <main-task>
\`\`\`

## Packages

| Package                   | Language   | Tests | Purpose             |
| ------------------------- | ---------- | ----- | ------------------- |
| [`pkg-a`](packages/pkg-a) | Python     | 40    | Primary analysis    |
| [`pkg-b`](packages/pkg-b) | Rust       | 14    | Performance compute |
| [`pkg-c`](packages/pkg-c) | TypeScript | 32    | APIs, web           |

## Performance

| Implementation | Key Metric | Baseline    |
| -------------- | ---------- | ----------- |
| Python + Numba | X.X ms     | baseline    |
| Rust           | X.X ms     | Y.Yx faster |

## Architecture

\`\`\`
project/
├── packages/
│ ├── pkg-a/
│ └── pkg-b/
├── data/
└── artifacts/
\`\`\`

## Documentation

- [Architecture](docs/ARCHITECTURE.md)
- [Domain Concepts](docs/CONCEPTS.md)

## License

MIT
```

---

## Phase 8: Release Workflow Setup

Automate versioning and changelog generation using semantic-release.

> **Full documentation**: See `itp:semantic-release` skill for comprehensive release workflow patterns, troubleshooting, and advanced configurations.

### Root package.json

Create `package.json` in the monorepo root for semantic-release:

```json
{
  "name": "<project-name>",
  "version": "<version>",
  "private": true,
  "description": "Polyglot monorepo for <domain>",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/<owner>/<repo>.git"
  },
  "author": "<owner>",
  "license": "MIT",
  "devDependencies": {
    "@semantic-release/changelog": "^6.0.3",
    "@semantic-release/exec": "^6.0.3",
    "@semantic-release/git": "^10.0.1",
    "@semantic-release/github": "^11.0.1",
    "semantic-release": "^25.0.0"
  }
}
```

> **Note**: Set `version` to `"0.0.0"` for new projects. Semantic-release will bump it on first release.

Install dependencies: `npm install`

### .releaserc.yml Configuration

Create `.releaserc.yml` in the monorepo root:

> **Warning**: The `@semantic-release/exec` plugin uses Lodash templates which conflict with bash `${VAR:-default}` syntax. Use `<%= %>` for semantic-release variables or avoid bash default syntax. See [Troubleshooting: Lodash Template Conflicts](../../semantic-release/references/troubleshooting.md#semantic-releaseexec-lodash-template-conflicts).

```yaml
branches:
  - main

plugins:
  # Preflight: Block release if working directory is dirty
  # NOTE: Avoid ${VAR:-default} bash syntax in exec commands (Lodash conflict)
  - - "@semantic-release/exec"
    - verifyConditionsCmd: |
        if [ -n "$(git status --porcelain)" ]; then
          echo "Working directory not clean"
          exit 1
        fi
  - - "@semantic-release/commit-analyzer"
    - releaseRules:
        # All commit types trigger patch for consistent versioning
        - { type: "docs", release: "patch" }
        - { type: "chore", release: "patch" }
        - { type: "style", release: "patch" }
        - { type: "refactor", release: "patch" }
        - { type: "test", release: "patch" }
        - { type: "build", release: "patch" }
        - { type: "ci", release: "patch" }
        - { type: "revert", release: "patch" }
  - "@semantic-release/release-notes-generator"
  - "@semantic-release/changelog"
  - - "@semantic-release/git"
    - assets:
        - CHANGELOG.md
        - package.json
      message: "chore(release): ${nextRelease.version} [skip ci]"
  - "@semantic-release/github"
```

### mise Release Tasks

Create file-based tasks in `.mise/tasks/release/`:

```bash
mkdir -p .mise/tasks/release
```

**.mise/tasks/release/preflight**:

```bash
#!/usr/bin/env bash
#MISE description="Phase 1: Validate prerequisites for release"
set -euo pipefail

echo "═══════════════════════════════════════════════════════════"
echo "  Phase 1: PREFLIGHT"
echo "═══════════════════════════════════════════════════════════"

# Check 1: Working directory clean
echo "→ Checking working directory..."
if [[ -n "$(git status --porcelain)" ]]; then
    echo "  ✗ Working directory not clean"
    git status --short
    exit 1
fi
echo "  ✓ Working directory clean"

# Check 2: GitHub authentication (no API calls - prevents process storms)
echo "→ Checking GitHub authentication..."
if [[ -z "${GH_TOKEN:-}" ]]; then
    echo "  ✗ GH_TOKEN not set"
    echo "    Ensure mise.toml uses read_file() pattern"
    exit 1
fi
echo "  ✓ GH_TOKEN present (${#GH_TOKEN} chars)"

# Check 3: On main branch
echo "→ Checking branch..."
BRANCH=$(git branch --show-current)
if [[ "$BRANCH" != "main" ]]; then
    echo "  ✗ Not on main branch (current: $BRANCH)"
    exit 1
fi
echo "  ✓ On main branch"

# Check 4: Releasable commits exist
echo "→ Checking for releasable commits..."
LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
if [[ -n "$LATEST_TAG" ]]; then
    COMMITS=$(git log "$LATEST_TAG"..HEAD --oneline 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$COMMITS" -eq 0 ]]; then
        echo "  ✗ No commits since $LATEST_TAG"
        exit 1
    fi
    echo "  ✓ Found $COMMITS commits since $LATEST_TAG"
else
    COMMITS=$(git log --oneline 2>/dev/null | wc -l | tr -d ' ')
    echo "  ✓ No previous tags, $COMMITS commits to release"
fi

# Check 5: Tests pass (optional but recommended)
echo "→ Running tests..."
if mise run test >/dev/null 2>&1; then
    echo "  ✓ Tests passed"
else
    echo "  ⚠ Tests failed (continuing anyway)"
fi

echo ""
echo "✓ All preflight checks passed"
echo ""
```

**.mise/tasks/release/version**:

```bash
#!/usr/bin/env bash
#MISE description="Phase 2: Run semantic-release (version bump + changelog)"
# Note: No dependency on preflight - release:full handles the chain
set -euo pipefail

echo "═══════════════════════════════════════════════════════════"
echo "  Phase 2: VERSION (semantic-release)"
echo "═══════════════════════════════════════════════════════════"

# Ensure node_modules are installed
if [[ ! -d "node_modules" ]]; then
    echo "→ Installing npm dependencies..."
    npm install --silent
fi

# Run semantic-release
semantic-release --no-ci

echo ""
echo "✓ Version phase complete"
echo ""
```

**.mise/tasks/release/full**:

```bash
#!/usr/bin/env bash
#MISE description="Complete release workflow"
#MISE depends=["release:preflight"]
set -euo pipefail

echo ""
echo "╔═══════════════════════════════════════════════════════════╗"
echo "║  Full Release Workflow                                     ║"
echo "╚═══════════════════════════════════════════════════════════╝"
echo ""

# Phase 2: Version
mise run release:version

echo ""
echo "╔═══════════════════════════════════════════════════════════╗"
echo "║  ✓ Release workflow complete!                             ║"
echo "╚═══════════════════════════════════════════════════════════╝"
echo ""
```

Make tasks executable:

```bash
chmod +x .mise/tasks/release/*
```

### Release Commands

| Command                      | Purpose                                        |
| ---------------------------- | ---------------------------------------------- |
| `mise run release:full`      | Complete 2-phase release (preflight + version) |
| `mise run release:preflight` | Validate prerequisites only                    |
| `mise run release:version`   | Run semantic-release only                      |

### Update .gitignore

Add npm artifacts:

```gitignore
# npm
node_modules/
package-lock.json  # Optional: some prefer to commit this
```

### First Release

```bash
# 1. Install dependencies
npm install

# 2. Commit release infrastructure
git add package.json .releaserc.yml .mise/tasks/release/
git commit -m "build: add semantic-release configuration and mise tasks

SRED-Type: support-work
SRED-Claim: RELEASE-INFRA"

# 3. Run first release
mise run release:full
```

### SR&ED Commit Integration

If using SR&ED commit conventions (see SR&ED section below), commits must include trailers:

```
<type>(<scope>): <description>

<body>

SRED-Type: <category>
SRED-Claim: <claim-id>
```

The `sred-commit-guard` hook (from itp-hooks) validates this format. Install via:

```bash
/itp:hooks install
```

---

## Performance Insights: Language Selection

Based on real benchmarks with 1M data points (trading fitness calculations):

| Implementation         | ITH Analysis | Overall     | Notes                                  |
| ---------------------- | ------------ | ----------- | -------------------------------------- |
| **Python + Numba JIT** | 5.5 ms       | Baseline    | LLVM-compiled, competitive with native |
| **Rust (native)**      | 4.0 ms       | 1.4x faster | Best for complex algorithms            |
| **Bun/TypeScript**     | 10.3 ms      | 1.9x slower | Good for APIs, async I/O               |

**Key Insights**:

1. **Numba JIT is remarkably competitive** — For numerical code, Numba compiles to LLVM machine code at runtime, matching or exceeding Rust for simple operations.

2. **Rust advantage is in algorithmic complexity** — Rust shines with branching logic, state machines, and memory-intensive operations (1.4-3x faster on ITH epoch detection).

3. **TypeScript is fast enough for most use cases** — 10ms for 1M points is acceptable for APIs, dashboards, and batch processing.

**When to use each**:

| Scenario                      | Best Choice            |
| ----------------------------- | ---------------------- |
| Existing Python codebase      | Keep Python + Numba    |
| Performance-critical paths    | Rust via PyO3 bindings |
| Web API / real-time dashboard | Bun/TypeScript         |
| Batch processing > 10M points | Rust                   |
| Quick prototyping             | Python                 |

---

## SR&ED Commit Conventions (Canada CRA)

For projects claiming Scientific Research & Experimental Development (SR&ED) tax credits, commits must document work that maps to CRA's eligibility criteria.

### CRA Eligibility Criteria

| Criterion                     | Description                                       | Commit Evidence Needed        |
| ----------------------------- | ------------------------------------------------- | ----------------------------- |
| **Technological Uncertainty** | What couldn't be achieved using standard practice | `uncertainty:`, `experiment:` |
| **Technological Advancement** | New knowledge or capability gained                | `advancement:`, `benchmark:`  |
| **Scientific Content**        | Systematic investigation or search                | `research:`, `hypothesis:`    |
| **Experimental Development**  | Iterative testing to resolve uncertainty          | `experiment:`, `iteration:`   |

### SR&ED Commit Types

Extend conventional commits with SR&ED-specific prefixes:

```
<type>(<scope>): <description>

[optional body with SR&ED context]

[optional footer: SR&ED-CLAIM: <claim-id>]
```

**Standard Types** (conventional commits):

| Type       | Purpose                 | SR&ED Relevance                   |
| ---------- | ----------------------- | --------------------------------- |
| `feat`     | New feature             | May support advancement           |
| `fix`      | Bug fix                 | Rarely eligible                   |
| `docs`     | Documentation           | Supports systematic investigation |
| `refactor` | Code restructuring      | Rarely eligible                   |
| `test`     | Adding tests            | Supports experimental development |
| `perf`     | Performance improvement | May support advancement           |
| `chore`    | Maintenance             | Not eligible                      |

**SR&ED-Specific Types** (CRA-aligned):

| Type          | CRA Mapping               | Description                                    |
| ------------- | ------------------------- | ---------------------------------------------- |
| `experiment`  | Experimental Development  | Hypothesis testing, controlled experiments     |
| `research`    | Scientific Content        | Literature review, prior art analysis          |
| `uncertainty` | Technological Uncertainty | Document what standard practice couldn't solve |
| `advancement` | Technological Advancement | Document new knowledge or capability achieved  |
| `hypothesis`  | Scientific Content        | Formulate and document testable hypotheses     |
| `analysis`    | Scientific Content        | Data analysis, results interpretation          |
| `iteration`   | Experimental Development  | Iterative cycles to resolve uncertainty        |
| `benchmark`   | Technological Advancement | Quantitative proof of advancement              |

### Commit Message Examples

**Documenting Technological Uncertainty**:

```
uncertainty(ith-python): standard Sharpe ratio insufficient for epoch detection

The conventional Sharpe ratio calculation doesn't account for time-varying
volatility regimes. Standard practice (rolling windows) fails to identify
discrete fitness epochs where strategy performance exceeds drawdown-adjusted
thresholds.

Attempted approaches that failed:
- Rolling 30-day Sharpe windows: too noisy, false positives
- EWMA-weighted returns: loses epoch boundary precision
- Standard drawdown metrics: no TMAEG concept exists

SR&ED-CLAIM: 2026-Q1-ITH
```

**Documenting Experimental Work**:

```
experiment(core-rust): test SIMD vectorization for ITH epoch detection

Hypothesis: SIMD intrinsics can accelerate excess_gain_excess_loss by 4x+
over scalar implementation for datasets > 100K points.

Methodology:
- Control: scalar Rust implementation (current)
- Treatment: AVX2 vectorized implementation
- Dataset: synthetic NAV series, 1M points, 100 iterations

Expected outcome: Sub-linear scaling with data size due to cache efficiency.

SR&ED-CLAIM: 2026-Q1-ITH
```

**Documenting Technological Advancement**:

```
advancement(ith-python): Numba JIT achieves near-native performance

Technological advancement achieved: Python+Numba matches Rust performance
for numerical ITH calculations, eliminating need for FFI complexity.

Benchmark results (1M data points):
- Python+Numba: 5.5ms (ITH analysis)
- Rust native: 4.0ms (1.4x faster, within acceptable range)
- TypeScript: 10.3ms (baseline comparison)

This advances the state of practice by proving JIT-compiled Python is
viable for production trading fitness analysis, previously assumed to
require native code.

SR&ED-CLAIM: 2026-Q1-ITH
```

**Documenting Hypothesis Testing**:

```
hypothesis(core-bun): TypeScript strict mode improves type safety at runtime

Hypothesis: Enabling strict:true in tsconfig.json will catch array boundary
errors at compile time that currently cause silent NaN propagation.

Test plan:
1. Enable strict mode
2. Fix all compile-time errors
3. Run existing test suite
4. Measure NaN-related failures before/after

Expected outcome: Zero runtime NaN errors from array access patterns.

SR&ED-CLAIM: 2026-Q1-ITH
```

### SR&ED Documentation Structure

Create `docs/SRED.md` to aggregate claim evidence:

```markdown
# SR&ED Claim Evidence

## Claim Period: 2026-Q1

### Project: ITH (Investment Time Horizon) Analysis

**Technological Uncertainty**:

- Standard fitness metrics (Sharpe, Sortino) don't capture epoch-based performance
- No existing solution for TMAEG (Target Maximum Acceptable Excess Gain) calculation
- Uncertainty in optimal JIT compilation strategy for numerical Python

**Technological Advancement**:

- Novel ITH epoch detection algorithm
- Proof that Numba JIT matches native Rust for trading calculations
- Cross-language type system via JSON Schema code generation

**Systematic Investigation**:

- Benchmark-driven development with controlled experiments
- Iterative refinement of TMAEG calculation methodology
- Comparative analysis across Python, Rust, TypeScript implementations

### Commit Log (SR&ED Tagged)

| Date       | Commit Hash | Type        | Description                     |
| ---------- | ----------- | ----------- | ------------------------------- |
| 2026-01-15 | abc123      | uncertainty | Standard Sharpe insufficient    |
| 2026-01-16 | def456      | experiment  | SIMD vectorization test         |
| 2026-01-17 | ghi789      | advancement | Numba achieves near-native perf |

### Time Allocation

| Activity                 | Hours | % of Total |
| ------------------------ | ----- | ---------- |
| Experimental Development | 40    | 50%        |
| Applied Research         | 24    | 30%        |
| Documentation & Analysis | 16    | 20%        |
```

### Git Log Extraction for Claims

Extract SR&ED-tagged commits for claim preparation:

```bash
# List all SR&ED commits
git log --oneline --grep="SR&ED-CLAIM"

# Extract by claim ID
git log --grep="SR&ED-CLAIM: 2026-Q1-ITH" --format="%h|%ad|%s" --date=short

# Generate claim summary
git log --grep="SR&ED-CLAIM" --format="| %ad | %h | %s |" --date=short > docs/sred-commits.md
```

### GitHub Labels for SR&ED

```bash
# SR&ED claim tracking labels
gh label create "sred:uncertainty" --color "D93F0B" --description "Documents technological uncertainty"
gh label create "sred:advancement" --color "0E8A16" --description "Documents technological advancement"
gh label create "sred:experiment" --color "1D76DB" --description "Experimental development work"
gh label create "sred:research" --color "5319E7" --description "Scientific research activity"
gh label create "sred:eligible" --color "FBCA04" --description "Potentially SR&ED eligible"
```

### SR&ED Commit Enforcement (Claude Code Hook)

Enforce dual commit types (conventional + SR&ED) via PreToolUse hook.

**Recommended format** (Git trailers for metadata):

```
<conventional-type>(<scope>): <description>

<body>

SRED-Type: <category>
SRED-Claim: <claim-id>
```

**Why Git trailers?**

| Approach                         | Parser Support | Extractable              | Recommendation        |
| -------------------------------- | -------------- | ------------------------ | --------------------- |
| `feat/experiment:` (dual prefix) | Breaks parsers | No                       | Avoid                 |
| `feat(sred):` (scope)            | Good           | Partial                  | OK for categorization |
| `SRED-Type:` (trailer)           | Excellent      | `git interpret-trailers` | **Best for metadata** |

**Hook installation** (add to `~/.claude/settings.json`):

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "bash $HOME/.claude/plugins/marketplaces/cc-skills/plugins/itp-hooks/hooks/sred-commit-guard.sh",
            "timeout": 5000
          }
        ]
      }
    ]
  }
}
```

**Git commit-msg hook** (for non-Claude commits):

```bash
#!/bin/bash
# .githooks/commit-msg
exec bash /path/to/sred-commit-guard.sh --git-hook "$1"
```

Enable with: `git config core.hooksPath .githooks`

**Extract SR&ED data for claims**:

```bash
# All SRED-Type values from commits
git log --format='%(trailers:key=SRED-Type,valueonly)' | grep -v '^$' | sort | uniq -c

# Export for claim reporting
git log --since="2026-01-01" --format="%ad|%s|%(trailers:key=SRED-Type,valueonly)|%(trailers:key=SRED-Claim,valueonly)" --date=short
```

---

## Success Criteria

The bootstrap is complete when:

**Infrastructure (Phases 0-5)**:

- [ ] All `CLAUDE.md` files exist and link correctly
- [ ] `pants list ::` shows all targets (or `mise run affected` for lightweight variant)
- [ ] `pants --changed-since=origin/main list` runs without error
- [ ] `mise tasks` shows convenience wrappers
- [ ] `.mcp.json` is valid JSON
- [ ] Each package has BUILD file (or package.json/Cargo.toml/pyproject.toml)
- [ ] `logs/` directory exists (gitignored)
- [ ] Initial commit is made

**Types (Phase 6)**:

- [ ] JSON Schema files exist in `packages/shared-types/schemas/`
- [ ] `scripts/generate-types.sh` generates valid code for all languages
- [ ] Generated types are referenced in package CLAUDE.md files

**GitHub (Phase 7)**:

- [ ] Repository has description set
- [ ] Repository has relevant topics (5-10 recommended)
- [ ] Standard labels created (pkg:_, type:_)
- [ ] LICENSE file exists in root
- [ ] README.md has badges, quick start, package table
- [ ] git-town configured with main branch

**SR&ED Documentation (Optional)**:

- [ ] `docs/SRED.md` created with claim structure
- [ ] SR&ED labels created (sred:uncertainty, sred:advancement, etc.)
- [ ] Commit message convention documented
- [ ] Git log extraction scripts available

**Release Workflow (Phase 8)**:

- [ ] `package.json` exists with semantic-release dependencies
- [ ] `.releaserc.yml` configuration present
- [ ] `.mise/tasks/release/{preflight,version,full}` tasks created and executable
- [ ] `npm install` completes without errors
- [ ] `mise run release:preflight` passes all checks
- [ ] First release creates GitHub release with changelog

---

## Maintenance Protocol

When adding new packages:

1. Create directory under `packages/` or `services/`
2. Add `CLAUDE.md` following existing pattern
3. Run `pants tailor` to generate BUILD file
4. Link from root `CLAUDE.md` package map
5. Run `mise run reindex` for code search

---

## Variant: Lightweight (No Pants)

For smaller projects (< 10 packages), skip Pants and use simple scripts:

### scripts/affected.sh

```bash
#!/usr/bin/env bash
# Detect affected packages via git diff
set -euo pipefail

BASE_BRANCH="${1:-origin/main}"
CHANGED_FILES=$(git diff --name-only "$BASE_BRANCH"...HEAD)

# Map files to packages
for file in $CHANGED_FILES; do
    if [[ "$file" == packages/* ]]; then
        echo "$file" | cut -d'/' -f2 | sort -u
    fi
done
```

### mise.toml (no Pants)

```toml
[tasks.test]
description = "Test all packages"
run = """
cd packages/core-python && uv run pytest
cd ../core-rust && cargo test
cd ../core-bun && bun test
"""

[tasks."test:affected"]
description = "Test affected packages"
run = "bash scripts/affected.sh | xargs -I{} bash -c 'cd packages/{} && mise run test'"
```

This variant was used successfully for the trading-fitness monorepo.

---

## Testing Patterns by Language

### Python (pytest)

```python
# packages/core-python/tests/conftest.py
import pytest
import numpy as np

@pytest.fixture
def sample_nav_data():
    """Generate synthetic NAV series for testing."""
    rng = np.random.default_rng(42)
    returns = rng.normal(0.0005, 0.02, 1000)
    return 100 * np.cumprod(1 + returns)
```

Run: `uv run pytest` or `pants test packages/core-python::`

### Rust (built-in)

```rust
// packages/core-rust/src/lib.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_max_drawdown_uptrend() {
        let nav = vec![1.0, 1.1, 1.2, 1.3];
        assert_eq!(max_drawdown(&nav), 0.0);
    }
}
```

Run: `cargo test` or `pants test packages/core-rust::`

### TypeScript (bun:test)

```typescript
// packages/core-bun/src/metrics.test.ts
import { describe, expect, test } from "bun:test";
import { maxDrawdown } from "./metrics";

describe("maxDrawdown", () => {
  test("returns 0 for uptrend", () => {
    expect(maxDrawdown([100, 110, 120])).toBe(0);
  });
});
```

Run: `bun test` or `pants test packages/core-bun::`

### TypeScript Strict Mode Gotcha

With `strict: true`, array access returns `T | undefined`. Handle explicitly:

```typescript
// WRONG: TypeScript error "possibly undefined"
const value = array[i];
doSomething(value); // Error!

// CORRECT: Explicit undefined check
const value = array[i];
if (value === undefined) {
  return defaultValue;
}
doSomething(value); // OK
```

---

## Related Resources

**Build & Environment**:

- [polyglot-affected.md](./polyglot-affected.md) - Tool comparison and Pants + mise guide
- [Level 11: Pants + mise](../SKILL.md#level-11-polyglot-monorepo-with-pants--mise) - Quick reference
- [Pants Documentation](https://www.pantsbuild.org/)
- [mise Documentation](https://mise.jdx.dev/)

**Release Workflow**:

- `itp:semantic-release` skill - Comprehensive release automation guide
- [semantic-release Documentation](https://semantic-release.gitbook.io/) - Official docs
- [local-release-workflow.md](../../semantic-release/references/local-release-workflow.md) - 4-phase workflow reference

**GitHub & Workflow**:

- [git-town Documentation](https://www.git-town.com/) - Branch workflow automation
- [Shields.io](https://shields.io/) - Badge generation for READMEs
- [Conventional Commits](https://www.conventionalcommits.org/) - Commit message specification

**Type Systems**:

- [JSON Schema Draft 2020-12](https://json-schema.org/draft/2020-12/schema) - Cross-language type definitions

**SR&ED (Canada)**:

- [CRA SR&ED Program](https://www.canada.ca/en/revenue-agency/services/scientific-research-experimental-development-tax-incentive-program.html) - Official program page
- [SR&ED Eligibility Criteria](https://www.canada.ca/en/revenue-agency/services/scientific-research-experimental-development-tax-incentive-program/eligibility-work-sred-tax-incentives.html) - What qualifies
- [SR&ED Claim Guide T4088](https://www.canada.ca/en/revenue-agency/services/forms-publications/publications/t4088.html) - Claiming procedures
